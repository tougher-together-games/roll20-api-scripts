

<!DOCTYPE html>
<html lang="en">

<head>
  
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title> minified/easy-utils/easy-utils.min.js</title>

  <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="./build/entry.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <link href="https://fonts.googleapis.com/css?family=Roboto:100,400,700|Inconsolata,700" rel="stylesheet">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
  <link type="text/css" rel="stylesheet" href="https://jmblog.github.io/color-themes-for-google-code-prettify/themes/tomorrow-night.min.css">
  <link type="text/css" rel="stylesheet" href="styles/app.min.css">
  <link type="text/css" rel="stylesheet" href="styles/iframe.css">
  <link type="text/css" rel="stylesheet" href="">
  <script async defer src="https://buttons.github.io/buttons.js"></script>

  
</head>



<body class="layout small-header">
    <div id="stickyNavbarOverlay"></div>
    

<div class="top-nav">
    <div class="inner">
        <a id="hamburger" role="button" class="navbar-burger" aria-label="menu" aria-expanded="false">
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
        </a>
        <div class="logo">
            
             
                <a href="index.html">
                    <h1 class="navbar-item">Roll20 API Scripts Documentation</h1>
                </a>
            
        </div>
        <div class="menu">
            
            <div class="navigation">
                <a
                    href="index.html"
                    class="link"
                >
                    Documentation
                </a>
                
                
                
            </div>
        </div>
    </div>
</div>
    <div id="main">
        <div
            class="sidebar "
            id="sidebarNav"
        >
            
            <nav>
                
                    <h2><a href="index.html">Documentation</a></h2><div class="category"><h3>Namespaces</h3><ul><li><a href="functionLoaders%25250A%25250AUtility%252520functions%252520for%252520Roll20%252520modules,%252520built%252520with%252520double%252520closures%252520for%252520efficiency%252520and%252520flexibility.%25250A%25250A-%252520__Purpose___%25250A%252520%252520-%252520Reduce%252520memory%252520usage%252520by%252520only%252520instantiating%252520functions%252520when%252520requested.%25250A%252520%252520-%252520Provide%252520customized%252520behavior%252520for%252520each%252520module%252520by%252520wrapping%252520functions%252520with%252520%252560moduleSettings%252560.%25250A%252520%252520-%252520Ensure%252520consistency%252520across%252520modules%252520with%252520standardized%252520implementations%252520of%252520routine%252520functions.%25250A%25250A-%252520__Execution___.html">functionLoaders

Utility functions for Roll20 modules, built with double closures for efficiency and flexibility.

- **Purpose**:
  - Reduce memory usage by only instantiating functions when requested.
  - Provide customized behavior for each module by wrapping functions with `moduleSettings`.
  - Ensure consistency across modules with standardized implementations of routine functions.

- **Execution**:</a></li></ul><h3>Global</h3><ul><li><a href="global.html#EASY_MODULE_FORGE">EASY_MODULE_FORGE</a></li><li><a href="global.html#EASY_UTILS">EASY_UTILS</a></li></ul></div>
                
            </nav>
        </div>
        <div class="core" id="main-content-wrapper">
            <div class="content">
                <header class="page-title">
                    <p>Source</p>
                    <h1>minified/easy-utils/easy-utils.min.js</h1>
                </header>
                



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*!
 * @language: en-US
 * @title: easy-utils.js
 * @description: Utility library for Easy Modules in Roll20. Provides reusable, memory-efficient functions to simplify module development and reduce boilerplate.
 * @comment: Developed using VSCode with extensions: Comment Anchors, ESLint, Inline Hasher (for ELF hash of dictionary transUnitIds), Spell Checker, and Live Server, along with Grunt for task automation.
 * @author: Mhykiel
 * @version: 0.1.0
 * @license: MIT License
 * @repository: {@link https://github.com/Tougher-Together-Gaming/roll20-api-scripts/blob/main/src/easy-utils/easy-utils.js|GitHub Repository}
 */
// ANCHOR Object: EASY_MODULE_FORGE
let EASY_MODULE_FORGE = (() => {
    let factories = {};
    return {
        // ANCHOR Method: getFactory
        getFactory: ({
            name
        }) => factories.hasOwnProperty(name) ? factories[name] : null,
        // ANCHOR Method: setFactory
        setFactory: ({
            name,
            factory
        }) => {
            factories[name] = factory;
        },
        // ANCHOR Method: getFactoryNames
        getFactoryNames: () => Object.keys(factories)
    };
})(), EASY_UTILS = (() => {
    // ANCHOR Property: globalSettings
    let globalSettings = {
        sharedVaultName: "EasyModuleVault",
        sharedForgeName: "EASY_MODULE_FORGE",
        defaultLanguage: "enUS"
    }, moduleSettings = {
        readableName: "Easy-Utils",
        chatApiName: "ezutils",
        globalName: "EASY_UTILS",
        version: "1.0.0",
        author: "Mhykiel",
        verbose: !1
    }, factoryFunctions = [ "createPhraseFactory", "createTemplateFactory", "createThemeFactory" ], Utils = {}, PhraseFactory = {}, functionLoaders = {
        // ANCHOR Function Loader: applyCssToHtmlJson
        /**
		 * @summary Applies CSS (provided as JSON) to an HTML-like structure (also provided as JSON).
		 * This function parses the CSS rules and HTML structure, merges styles (with respect to !important),
		 * handles pseudo-classes, attribute selectors, classes, IDs, and more, then returns a new HTML JSON
		 * structure that includes computed styles as if the HTML had in-line styles.
		 * 
		 * @see convertCssToJson
		 * @see convertHtmlToJson
		 */
        applyCssToHtmlJson: function() {
            return moduleSettings => {
                let logSyslogMessage = EASY_UTILS.getFunction({
                    functionName: "logSyslogMessage",
                    moduleSettings: moduleSettings
                });
                function gatherAllNodes(nodeOrArray, results = [], parent = null) {
                    if (Array.isArray(nodeOrArray)) for (var child of nodeOrArray) gatherAllNodes(child, results, parent); else if (nodeOrArray &amp;&amp; "object" == typeof nodeOrArray &amp;&amp; (nodeOrArray.parentNode = parent, 
                    results.push(nodeOrArray), Array.isArray(nodeOrArray.children))) for (var c of nodeOrArray.children) gatherAllNodes(c, results, nodeOrArray);
                    return results;
                }
                function parseChunk(chunk) {
                    var data = {
                        tag: null,
                        id: null,
                        classes: [],
                        attributes: {},
                        pseudo: {
                            nthChild: null,
                            firstChild: !1,
                            lastChild: !1
                        }
                    };
                    let working = chunk.trim();
                    for (var attrMatch, attrRegex = /\[([\w-]+)\s*=\s*"([^"]+)"\]/g; null !== (attrMatch = attrRegex.exec(working)); ) {
                        var attrKey = attrMatch[1];
                        data.attributes[attrKey] = attrMatch[2];
                    }
                    working = working.replace(attrRegex, "");
                    for (var cMatch, chunk = /#([\w-]+)/, idMatch = chunk.exec(working), classRegex = (idMatch &amp;&amp; (data.id = idMatch[1], 
                    working = working.replace(chunk, "")), /\.([\w-]+)/g); null !== (cMatch = classRegex.exec(working)); ) data.classes.push(cMatch[1]);
                    working = working.replace(classRegex, ""), /:first-child/.test(working) &amp;&amp; (data.pseudo.firstChild = !0, 
                    working = working.replace(":first-child", "")), /:last-child/.test(working) &amp;&amp; (data.pseudo.lastChild = !0, 
                    working = working.replace(":last-child", ""));
                    idMatch = /:nth-child\(\s*(even|odd|\d+)\s*\)/, chunk = idMatch.exec(working), 
                    chunk &amp;&amp; (chunk = chunk[1], data.pseudo.nthChild = "even" === chunk || "odd" === chunk ? chunk : parseInt(chunk, 10), 
                    working = working.replace(idMatch, "")), chunk = working.trim();
                    return chunk &amp;&amp; (data.tag = chunk), data;
                }
                function doesNodeMatchChunk(node, chunkData) {
                    if (!(chunkData.tag &amp;&amp; chunkData.tag !== node.element || chunkData.id &amp;&amp; node.props?.id !== chunkData.id)) {
                        if (0 &lt; chunkData.classes.length) {
                            var neededClass, nodeClasses = node.props?.class || [];
                            for (neededClass of chunkData.classes) if (!nodeClasses.includes(neededClass)) return;
                        }
                        for (var [ k, v ] of Object.entries(chunkData.attributes)) if (node.props?.[k] !== v) return;
                        var {
                            firstChild: chunkData,
                            lastChild,
                            nthChild
                        } = chunkData.pseudo;
                        if (chunkData || lastChild || null !== nthChild) {
                            var parent = node.parentNode;
                            if (!parent || !Array.isArray(parent.children)) return;
                            var idx = parent.children.indexOf(node);
                            if (chunkData &amp;&amp; 0 !== idx) return;
                            if (lastChild &amp;&amp; idx !== parent.children.length - 1) return;
                            if (null !== nthChild) if ("odd" === nthChild) {
                                if (idx % 2 != 0) return;
                            } else if ("even" === nthChild) {
                                if (idx % 2 != 1) return;
                            } else if (idx !== nthChild - 1) return;
                        }
                        return 1;
                    }
                }
                function filterByChain(htmlRoot, chain) {
                    let currentSet = ((nodes, chunkData) => {
                        var n, results = [];
                        for (n of nodes) doesNodeMatchChunk(n, chunkData) &amp;&amp; results.push(n);
                        return results;
                    })(gatherAllNodes(htmlRoot, []), parseChunk(chain[0]));
                    for (let i = 1; i &lt; chain.length; i++) {
                        var matchedNode, chunkData = parseChunk(chain[i]), nextSet = [];
                        for (matchedNode of currentSet) if (Array.isArray(matchedNode.children)) for (var childNode of matchedNode.children) doesNodeMatchChunk(childNode, chunkData) &amp;&amp; nextSet.push(childNode);
                        currentSet = nextSet;
                    }
                    return currentSet;
                }
                function filterBySelector(htmlRoot, selector) {
                    var chain, node, selector = (selector => {
                        var group, allChains = [];
                        for (group of selector.split(",").map(s => s.trim())) {
                            var chain = group.split(">").map(s => s.trim());
                            allChains.push(chain);
                        }
                        return allChains;
                    })(selector), resultSet = new Set();
                    for (chain of selector) for (node of filterByChain(htmlRoot, chain)) resultSet.add(node);
                    return [ ...resultSet ];
                }
                function mergeStyles(nodeStyle, newStyles, rootVars) {
                    for (var [ prop, val ] of Object.entries(newStyles)) nodeStyle[prop] = ((value, rootVariables) => "string" != typeof value ? value : value.replace(/var\((--[\w-]+)\)/g, (_, varName) => rootVariables[varName] || `var(${varName})`))(val, rootVars);
                }
                return ({
                    cssJson,
                    htmlJson
                }) => {
                    try {
                        let cssRules = "string" == typeof cssJson ? JSON.parse(cssJson) : cssJson, htmlTree = "string" == typeof htmlJson ? JSON.parse(htmlJson) : htmlJson;
                        Array.isArray(cssRules) || (cssRules = []), Array.isArray(htmlTree) || (htmlTree = [ htmlTree ]);
                        var rule, {
                            rootVariables,
                            updatedRules
                        } = ((cssRules, htmlTree) => {
                            if ((rootIndex = cssRules.findIndex(r => ":root" === r.selector)) &lt; 0) return {
                                rootVariables: {},
                                updatedRules: cssRules
                            };
                            var propKey, propValue, node, {
                                style: rootIndex = {}
                            } = cssRules[rootIndex], rootVariables = {}, rootNonVars = {};
                            for ([ propKey, propValue ] of Object.entries(rootIndex)) propKey.startsWith("--") ? rootVariables[propKey] = propValue : rootNonVars[propKey] = propValue;
                            let rootContainerNode = null;
                            for (node of gatherAllNodes(htmlTree)) if ("rootContainer" === node.props?.id) {
                                rootContainerNode = node;
                                break;
                            }
                            return rootContainerNode &amp;&amp; (rootContainerNode.props = rootContainerNode.props || {}, 
                            rootContainerNode.props.style = rootContainerNode.props.style || {}, 
                            Object.assign(rootContainerNode.props.style, rootNonVars)), 
                            {
                                rootVariables: rootVariables,
                                updatedRules: cssRules.filter(r => ":root" !== r.selector)
                            };
                        })(cssRules, htmlTree);
                        for (rule of cssRules = updatedRules) {
                            var node, {
                                selector,
                                style
                            } = rule;
                            for (node of filterBySelector(htmlTree, selector)) node.props = node.props || {}, 
                            node.props.style = node.props.style || {}, mergeStyles(node.props.style, style, rootVariables);
                        }
                        return function removeParentRefs(objOrArray) {
                            if (Array.isArray(objOrArray)) for (var item of objOrArray) removeParentRefs(item); else if (objOrArray &amp;&amp; "object" == typeof objOrArray &amp;&amp; (delete objOrArray.parentNode, 
                            Array.isArray(objOrArray.children))) for (var child of objOrArray.children) removeParentRefs(child);
                        }(htmlTree), moduleSettings.verbose &amp;&amp; logSyslogMessage({
                            severity: 7,
                            tag: "applyCssToHtmlJson",
                            transUnitId: "70000",
                            message: "Success"
                        }), JSON.stringify(htmlTree, null, 2);
                    } catch (err) {
                        return logSyslogMessage({
                            severity: 3,
                            tag: "applyCssToHtmlJson",
                            transUnitId: "30000",
                            message: "" + err
                        }), htmlJson;
                    }
                };
            };
        },
        // ANCHOR Function Loader: convertCssToJson
        convertCssToJson: function() {
            return moduleSettings => {
                let logSyslogMessage = EASY_UTILS.getFunction({
                    functionName: "logSyslogMessage",
                    moduleSettings: moduleSettings
                }), compareSpecificity = (ruleA, ruleB) => ruleA.weight !== ruleB.weight ? ruleA.weight - ruleB.weight : ruleA.index - ruleB.index;
                return ({
                    css
                }) => {
                    try {
                        var cleanedCss = css.replace(/\/\*[\s\S]*?\*\//g, "").replace(/\n/g, " ").replace(/\s+/g, " ").trim();
                        let ruleList = [];
                        var ruleMatch, ruleRegex = /([^\{]+)\{([^\}]+)\}/g, propertiesRegex = /([\w-]+)\s*:\s*([^;]+);/g;
                        let ruleIndex = 0;
                        for (;ruleMatch = ruleRegex.exec(cleanedCss); ) {
                            var propMatch, selectorsRaw = ruleMatch[1].trim(), propertiesRaw = ruleMatch[2].trim();
                            let styleObj = {};
                            for (;propMatch = propertiesRegex.exec(propertiesRaw); ) {
                                var propKey = propMatch[1].trim(), propValue = propMatch[2].trim();
                                styleObj[propKey] = propValue;
                            }
                            selectorsRaw.split(",").map(sel => sel.replace(/\s*>\s*/g, ">").replace(/\s*\+\s*/g, "+").replace(/\s*~\s*/g, "~").trim()).forEach(aSelector => {
                                var specificity = (selector => {
                                    selector = selector.replace(/\s*>\s*/g, ">").replace(/\s*\+\s*/g, "+").replace(/\s*~\s*/g, "~").replace(/,\n/g, ",").trim().split(/\s|>|\+|~(?![^\[]*\])/g).filter(Boolean);
                                    let a = 0, b = 0, c = 0;
                                    return selector.forEach(chunk => {
                                        chunk.split(/(?=[#.:\[])/).filter(Boolean).forEach(sub => {
                                            sub.startsWith("#") ? a += 1 : sub.startsWith(".") || sub.startsWith("[") ? b += 1 : sub.startsWith(":") ? sub.startsWith("::") ? c += 1 : b += 1 : "" !== sub.trim() &amp;&amp; (c += 1);
                                        });
                                    }), 100 * a + 10 * b + +c;
                                })(aSelector);
                                ruleList.push({
                                    selector: aSelector,
                                    style: {
                                        ...styleObj
                                    },
                                    weight: specificity,
                                    index: ruleIndex
                                }), ruleIndex++;
                            });
                        }
                        return ruleList.sort(compareSpecificity), moduleSettings.verbose &amp;&amp; logSyslogMessage({
                            severity: 7,
                            tag: "convertCssToJson",
                            transUnitId: "70000",
                            message: "Success"
                        }), JSON.stringify(ruleList, null, 2);
                    } catch (err) {
                        return logSyslogMessage({
                            severity: 4,
                            tag: "convertCssToJson",
                            transUnitId: "30000",
                            message: "" + err
                        }), JSON.stringify([]);
                    }
                };
            };
        },
        // ANCHOR Function Loader: convertHtmlToJson
        convertHtmlToJson: function() {
            return moduleSettings => {
                let logSyslogMessage = EASY_UTILS.getFunction({
                    functionName: "logSyslogMessage",
                    moduleSettings: moduleSettings
                });
                return ({
                    html
                }) => {
                    try {
                        var cleanedHtml = html.replace(/&lt;!--[\s\S]*?-->/g, "").replace(/\n/g, " ").replace(/\s+/g, " ").trim(), tokenRegex = /&lt;\/?\w+[^>]*>|[^&lt;>]+/g;
                        function getFullAncestorChain(stack, newElementName) {
                            stack = stack.map(node => node.element).join(">");
                            return stack ? stack + ">" + newElementName : newElementName;
                        }
                        var jsonStructure = (tokens => {
                            var rootContainer = {
                                element: "div",
                                props: {
                                    id: "rootContainer",
                                    style: {},
                                    class: [],
                                    inlineStyle: {}
                                },
                                children: [],
                                childIndex: 1,
                                fullAncestorChain: "rootContainer"
                            };
                            let stack = [];
                            return stack.push(rootContainer), tokens.forEach(token => {
                                var openingTagMatch = token.match(/^&lt;(\w+)([^>]*)>$/), closingTagMatch = token.match(/^&lt;\/(\w+)>$/), selfClosingTagMatch = token.match(/^&lt;(\w+)([^>]*)\/>$/);
                                if (selfClosingTagMatch) {
                                    var [ , selfClosingTagMatch, rawAttributes ] = selfClosingTagMatch, focusHtmlProps = {
                                        style: {},
                                        class: [],
                                        id: null,
                                        inlineStyle: {}
                                    };
                                    if (rawAttributes) for (var attributeRegex = /([\w-]+)\s*=\s*["']([^"']+)["']/g; attrMatch = attributeRegex.exec(rawAttributes); ) {
                                        var [ , attrMatch, attrValue ] = attrMatch;
                                        if ("style" === attrMatch) {
                                            let inlineStyleObj = {};
                                            attrValue.split(";").forEach(styleDecl => {
                                                var [ styleDecl, val ] = styleDecl.split(":").map(s => s.trim());
                                                styleDecl &amp;&amp; val &amp;&amp; (inlineStyleObj[styleDecl] = val);
                                            }), focusHtmlProps.inlineStyle = inlineStyleObj;
                                        } else "class" === attrMatch ? focusHtmlProps.class = attrValue.split(" ").filter(Boolean) : "id" === attrMatch ? focusHtmlProps.id = attrValue : focusHtmlProps[attrMatch] = attrValue;
                                    }
                                    var selfClosingNode = {
                                        element: selfClosingTagMatch,
                                        props: focusHtmlProps,
                                        children: [],
                                        childIndex: 0
                                    }, selfClosingTagMatch = (selfClosingNode.fullAncestorChain = getFullAncestorChain(stack, selfClosingTagMatch), 
                                    stack[stack.length - 1]);
                                    selfClosingTagMatch &amp;&amp; (selfClosingNode.childIndex = selfClosingTagMatch.children.length + 1, 
                                    selfClosingTagMatch.children.push(selfClosingNode));
                                } else if (openingTagMatch) {
                                    let [ , tagName, rawAttributes ] = openingTagMatch, focusHtmlProps = {
                                        style: {},
                                        class: [],
                                        id: null,
                                        inlineStyle: {}
                                    };
                                    if (rawAttributes) {
                                        let attributeRegex = /([\w-]+)\s*=\s*["']([^"']+)["']/g, attrMatch;
                                        for (;attrMatch = attributeRegex.exec(rawAttributes); ) {
                                            let [ , attrName, attrValue ] = attrMatch;
                                            if ("style" === attrName) {
                                                let inlineStyleObj = {};
                                                attrValue.split(";").forEach(styleDecl => {
                                                    var [ styleDecl, val ] = styleDecl.split(":").map(s => s.trim());
                                                    styleDecl &amp;&amp; val &amp;&amp; (inlineStyleObj[styleDecl] = val);
                                                }), focusHtmlProps.inlineStyle = inlineStyleObj;
                                            } else "class" === attrName ? focusHtmlProps.class = attrValue.split(" ").filter(Boolean) : "id" === attrName ? focusHtmlProps.id = attrValue : focusHtmlProps[attrName] = attrValue;
                                        }
                                    }
                                    selfClosingTagMatch = {
                                        element: tagName,
                                        props: focusHtmlProps,
                                        children: [],
                                        childIndex: 0
                                    };
                                    selfClosingTagMatch.fullAncestorChain = getFullAncestorChain(stack, tagName);
                                    let parent = stack[stack.length - 1];
                                    parent &amp;&amp; (selfClosingTagMatch.childIndex = parent.children.length + 1, 
                                    parent.children.push(selfClosingTagMatch)), 
                                    stack.push(selfClosingTagMatch);
                                } else if (closingTagMatch) stack.pop(); else {
                                    selfClosingNode = token.trim();
                                    if (selfClosingNode) {
                                        openingTagMatch = {
                                            element: "text",
                                            children: [ {
                                                innerText: selfClosingNode
                                            } ],
                                            childIndex: 0,
                                            fullAncestorChain: ""
                                        };
                                        let parent = stack[stack.length - 1];
                                        parent &amp;&amp; (openingTagMatch.childIndex = parent.children.length + 1, 
                                        openingTagMatch.fullAncestorChain = parent.fullAncestorChain + ">text", 
                                        parent.children.push(openingTagMatch));
                                    }
                                }
                            }), 1 !== stack.length &amp;&amp; logSyslogMessage({
                                severity: 3,
                                tag: "convertHtmlToJson",
                                transUnitId: "50000",
                                message: "Invalid Argument: Unclosed HTML tags detected. Ensure HTML is well-formed."
                            }), [ rootContainer ];
                        })((cleanedHtml.match(tokenRegex) || []).map(token => token.trim()).filter(Boolean)), output = JSON.stringify(jsonStructure, null, 2);
                        return moduleSettings.verbose &amp;&amp; logSyslogMessage({
                            severity: 7,
                            tag: "convertHtmlToJson",
                            transUnitId: "70000",
                            message: "Success"
                        }), output;
                    } catch (err) {
                        return logSyslogMessage({
                            severity: 4,
                            tag: "convertHtmlToJson",
                            transUnitId: "30000",
                            message: "" + err
                        }), JSON.stringify([ {
                            element: "div",
                            props: {
                                style: {},
                                class: [],
                                id: "rootContainer",
                                inlineStyle: {}
                            },
                            children: [ {
                                element: "h1",
                                props: {
                                    style: {},
                                    class: [],
                                    id: null,
                                    inlineStyle: {}
                                },
                                children: [ {
                                    element: "text",
                                    children: [ {
                                        innerText: "Malformed HTML"
                                    } ],
                                    childIndex: 1,
                                    fullAncestorChain: "rootContainer>h1>text"
                                } ],
                                childIndex: 1,
                                fullAncestorChain: "rootContainer>h1"
                            } ],
                            childIndex: 1,
                            fullAncestorChain: "rootContainer"
                        } ]);
                    }
                };
            };
        },
        // ANCHOR Function Loader: convertMarkdownToHtml
        convertMarkdownToHtml: function() {
            return moduleSettings => {
                let encodeCodeBlock = EASY_UTILS.getFunction({
                    functionName: "encodeCodeBlock",
                    moduleSettings: moduleSettings
                });
                return ({
                    content
                }) => {
                    content = [ ...content.split("\n") ];
                    let htmlArray = [], tagStack = [];
                    function addToHtmlArray(html, raw = !1) {
                        raw ? htmlArray.push(html) : htmlArray.push(processInline(html));
                    }
                    function closeAllTags() {
                        for (;0 &lt; tagStack.length; ) 0 !== tagStack.length &amp;&amp; addToHtmlArray(`&lt;/${tagStack.pop()}>`, !0);
                    }
                    function slugify(text) {
                        return text.toLowerCase().replace(/[^a-z0-9\s-]/g, "").trim().replace(/\s+/g, "-");
                    }
                    function processInline(text) {
                        return "string" != typeof text ? "" : text.replace(/\\\*/g, "&amp;#42;").replace(/!\[([^\]]*)\]\(([^)\s]+)(?:\s+"([^"]+)")?\)/g, '&lt;img src="$2" alt="$1" title="$3" />').replace(/\[([^\]]+)\]\(([^)\s]+)(?:\s+"([^"]+)")?\)/g, '&lt;a href="$2" title="$3">$1&lt;/a>').replace(/`([^`]+)`(?!`)/g, (match, code) => `&lt;code class="inline-code">${encodeCodeBlock({
                            text: code
                        })}&lt;/code>`).replace(/\^\^([^=]+)\^\^/g, "&lt;sup>$1&lt;/sup>").replace(/\^\_([^=]+)\_\^/g, "&lt;sub>$1&lt;/sub>").replace(/^-{3,}$/gm, '&lt;hr class="dash-hr" />').replace(/^\*{3,}$/gm, '&lt;hr class="asterisk-hr" />').replace(/^_{3,}$/gm, '&lt;hr class="underscore-hr" />').replace(/\*\*\*([^*]+)\*\*\*/g, '&lt;strong class="asterisk-strong">&lt;em class="asterisk-em">$1&lt;/em>&lt;/strong>').replace(/___([^_]+)___/g, '&lt;strong class="underscore-strong">&lt;em class="underscore-em">$1&lt;/em>&lt;/strong>').replace(/\*\*([^*]+)\*\*/g, '&lt;strong class="asterisk-strong">$1&lt;/strong>').replace(/__([^_]+)__/g, '&lt;strong class="underscore-strong">$1&lt;/strong>').replace(/\*([^*]+)\*/g, '&lt;em class="asterisk-em">$1&lt;/em>').replace(/_((?!&lt;[^>]*>).+?)_/g, '&lt;em class="underscore-em">$1&lt;/em>').replace(/~~([^~]+)~~/g, "&lt;del>$1&lt;/del>").replace(/==([^=]+)==/g, "&lt;mark>$1&lt;/mark>").replace(/^#{6} (.+)$/gm, (match, text) => `&lt;h6 id="${slugify(text)}">${text}&lt;/h6>`).replace(/^#{5} (.+)$/gm, (match, text) => `&lt;h5 id="${slugify(text)}">${text}&lt;/h5>`).replace(/^#{4} (.+)$/gm, (match, text) => `&lt;h4 id="${slugify(text)}">${text}&lt;/h4>`).replace(/^#{3} (.+)$/gm, (match, text) => `&lt;h3 id="${slugify(text)}">${text}&lt;/h3>`).replace(/^#{2} (.+)$/gm, (match, text) => `&lt;h2 id="${slugify(text)}">${text}&lt;/h2>`).replace(/^#{1} (.+)$/gm, (match, text) => `&lt;h1 id="${slugify(text)}">${text}&lt;/h1>`);
                    }
                    return function parseBlock(lines) {
                        for (;0 &lt; lines.length; ) {
                            var originalLine = lines.shift(), normalizedLine = originalLine.replace(/\t/g, "   ").replace(/&lt;style([^>]*)>/g, '&lt;div$1 style="display:none">').replace(/&lt;template([^>]*)>/g, '&lt;div$1 style="display:none">').replace(/&lt;\/style>/g, "&lt;/div>").replace(/&lt;\/template>/g, "&lt;/div>").replace(/^ \*(.*)/, "*$1").replace(/^ -/, "-").replace(/^\+/, "+").replace(/^(\s*)/, match => (match = 3 * Math.ceil(match.length / 3), 
                            " ".repeat(match))), meta = {
                                isEmpty: /^\s*$/.test(originalLine),
                                thisLine: normalizedLine.trim(),
                                indentLevel: normalizedLine.match(/^\s*/)[0].length
                            };
                            let doContinue = !1;
                            switch (!0) {
                              case /^:::/.test(meta.thisLine):
                                var openFenceMatch = meta.thisLine.match(/^:::\s*(.+)$/), closeFenceMatch = ":::" === meta.thisLine.trim();
                                openFenceMatch &amp;&amp; openFenceMatch[1] ? addToHtmlArray(`&lt;div class="${openFenceMatch[1].trim()}">`, !0) : closeFenceMatch &amp;&amp; addToHtmlArray("&lt;/div>", !0), 
                                doContinue = !0;
                                break;

                                /*case /^:::\s*(.*)/.test(meta.thisLine): {
										// 1) Determine if this is an open or close fence
										const openFenceMatch = meta.thisLine.match(/^:::\s+(\S.*)$/); // "::: some-class" => open
										const closeFenceMatch = meta.thisLine.match(/^:::\s*$/);       // ":::        " => close (no text)
		
										// If it's a close fence, we do not open a new div. Instead, we break out.
										if (closeFenceMatch) {
											// This scenario can happen if there's a stray ":::" or if a nested close is found.
											// Usually you'd decrement a nesting counter if you track that at a higher level.
											// But let's assume parseBlock is handling this scenario. We'll just skip or handle.
											// For demonstration, let's just skip further processing so it doesn't become a paragraph.
											doContinue = true;
											break;
										}
		
										// 2) It's an open fence if there's text after ":::"
										if (openFenceMatch) {
											const customFenceClasses = openFenceMatch[1].trim();  // e.g. "two-columns", "left hidden", etc.
											const hasHidden = customFenceClasses.includes("hidden");
											const hiddenStyle = hasHidden ? " style=\"display:none\"" : "";
		
											// Use a local nesting counter to track how many open fences belong to this block
											let nestedDivCount = 1;
											const customDivPocketDimension = [];
		
											// Open the custom block
											addToHtmlArray(`&lt;div class="${customFenceClasses}"${hiddenStyle}>`, true);
		
											// Consume lines inside this block
											let nextLine = lines.shift();
		
											while (nextLine !== undefined) {
		
												// Check for an open fence
												const nextOpenFenceMatch = nextLine.match(/^:::\s+(\S.*)$/);
												// Check for a close fence
												const nextCloseFenceMatch = nextLine.match(/^:::\s*$/);
		
												if (nextOpenFenceMatch) {
													// Another "open" fence => nested block
													nestedDivCount++;
													customDivPocketDimension.push(nextLine);
												}
												else if (nextCloseFenceMatch) {
													// Potentially a closing fence => reduce nesting
													nestedDivCount--;
													if (nestedDivCount === 0) {
														// We just closed the current block
														break;
													} else {
														// It's closing a nested block, so keep it in the pocket dimension
														customDivPocketDimension.push(nextLine);
													}
												}
												else {
													// Regular content line
													customDivPocketDimension.push(nextLine);
												}
		
												nextLine = lines.shift();
											}
		
											// Recursively parse the collected lines for nested blocks, lists, etc.
											parseBlock(customDivPocketDimension);
		
											// Close the custom block
											addToHtmlArray("&lt;/div>", true);
		
											// Prevent further processing of this line
											doContinue = true;
											break;
										}
		
										// If the line started with ":::", but didn't match open or close, 
										// it might be malformed or empty. Let's just skip it.
										doContinue = true;
										break;
									}*/
                              case /^```/.test(meta.thisLine):
                                if (openFenceMatch = meta.thisLine.match(/^```(\S.*)$/), 
                                !meta.thisLine.match(/^```$/) &amp;&amp; openFenceMatch) {
                                    addToHtmlArray(`&lt;pre data-role="code-block" data-info="${closeFenceMatch = openFenceMatch[1].trim() || "text"}" class="${closeFenceMatch}">&lt;code>`, !0);
                                    let nextLine = lines.shift();
                                    for (;void 0 !== nextLine &amp;&amp; !nextLine.match(/^```$/); ) addToHtmlArray(encodeCodeBlock({
                                        text: nextLine
                                    }) + "&lt;br />", !0), nextLine = lines.shift();
                                    addToHtmlArray("&lt;/code>&lt;/pre>", !0);
                                }
                                doContinue = !0;
                                break;

                              case /^>/.test(meta.thisLine):
                                {
                                    addToHtmlArray("&lt;blockquote>", !0);
                                    var blockquotePocketDimension = [];
                                    blockquotePocketDimension.push(meta.thisLine.replace(/^>\s*/, ""));
                                    let nextLine = lines.shift();
                                    for (;nextLine; ) {
                                        if (!/^>/.test(nextLine)) {
                                            lines.unshift(nextLine);
                                            break;
                                        }
                                        var updatedLine = nextLine.replace(/^>\s?/, "");
                                        blockquotePocketDimension.push(updatedLine), 
                                        nextLine = lines.shift();
                                    }
                                    parseBlock(blockquotePocketDimension), addToHtmlArray("&lt;/blockquote>", !0), 
                                    doContinue = !0;
                                    break;
                                }

                              case /^[-+*]\s+/.test(meta.thisLine):
                                var bulletType = (listMatch = meta.thisLine.match(/^([-+*])\s+(.*)/)) ? listMatch[1] : "-", listMatch = listMatch ? listMatch[2].trim() : "", indentLevel = Math.floor(meta.indentLevel / 3) + 1, currentListLevel = tagStack.filter(tag => "ul" === tag).length, bulletType = {
                                    "-": "dash-bullet",
                                    "+": "plus-bullet",
                                    "*": "asterisk-bullet"
                                }[bulletType] || "dash-bullet";
                                if (currentListLevel &lt; indentLevel) addToHtmlArray("&lt;ul>"), 
                                tagStack.push("ul"); else if (indentLevel &lt; currentListLevel) for (let i = currentListLevel; i > indentLevel; i--) addToHtmlArray("&lt;/ul>", !0), 
                                tagStack.pop();
                                addToHtmlArray(`&lt;li class="${bulletType}">${processInline(listMatch)}&lt;/li>`);
                                break;

                              case /^\d+\.\s+/.test(meta.thisLine):
                                {
                                    let listMatch = meta.thisLine.match(/^(\d+)\.\s+(.*)/);
                                    var listNumber = listMatch ? parseInt(listMatch[1], 10) : 1;
                                    let listItemContent = listMatch ? listMatch[2].trim() : "", indentLevel = Math.floor(meta.indentLevel / 3) + 1, currentListLevel = tagStack.filter(tag => "ol" === tag).length;
                                    if (indentLevel > currentListLevel) for (let i = currentListLevel; i &lt; indentLevel; i++) addToHtmlArray(1 &lt; listNumber ? `&lt;ol start="${listNumber}">` : "&lt;ol>"), 
                                    tagStack.push("ol"); else if (indentLevel &lt; currentListLevel) for (let i = currentListLevel; i > indentLevel; i--) addToHtmlArray("&lt;/ol>", !0), 
                                    tagStack.pop();
                                    let processedContent = processInline(listItemContent);
                                    addToHtmlArray(`&lt;li>${processedContent}&lt;/li>`);
                                    break;
                                }

                              case /^\|/.test(meta.thisLine):
                                {
                                    var tableLines = [ meta.thisLine ];
                                    let nextLine = lines.shift();
                                    for (;nextLine &amp;&amp; /^\|/.test(nextLine); ) tableLines.push(nextLine), 
                                    nextLine = lines.shift();
                                    let footerLine = null;
                                    if (nextLine &amp;&amp; "" !== nextLine.trim() &amp;&amp; !/^\|/.test(nextLine) ? footerLine = nextLine : nextLine &amp;&amp; lines.unshift(nextLine), 
                                    (currentListLevel = tableLines[1]) &amp;&amp; /^\|\s*:?-+:?\s*(\|\s*:?-+:?\s*)*\|$/.test(currentListLevel)) {
                                        bulletType = tableLines[0].slice(1, -1).split("|").map(h => h.trim());
                                        let alignments = currentListLevel.slice(1, -1).split("|").map(s => s.trim());
                                        addToHtmlArray("&lt;table>"), addToHtmlArray("&lt;thead>&lt;tr>"), 
                                        bulletType.forEach((header, index) => {
                                            let style = "";
                                            /^:-+:?$/.test(alignments[index]) ? style = ' style="text-align:center"' : /^:-+$/.test(alignments[index]) ? style = ' style="text-align:left"' : /^-+:$/.test(alignments[index]) &amp;&amp; (style = ' style="text-align:right"'), 
                                            addToHtmlArray(`&lt;th${style}>${processInline(header)}&lt;/th>`);
                                        }), addToHtmlArray("&lt;/tr>&lt;/thead>"), addToHtmlArray("&lt;tbody>");
                                        for (let i = 2; i &lt; tableLines.length; i++) {
                                            var cells = tableLines[i].slice(1, -1).split("|").map(c => c.trim());
                                            addToHtmlArray("&lt;tr>"), cells.forEach((cell, index) => {
                                                let style = "";
                                                /^:-+:?$/.test(alignments[index]) ? style = ' style="text-align:center"' : /^:-+$/.test(alignments[index]) ? style = ' style="text-align:left"' : /^-+:$/.test(alignments[index]) &amp;&amp; (style = ' style="text-align:right"'), 
                                                addToHtmlArray(`&lt;td${style}>${processInline(cell)}&lt;/td>`);
                                            }), addToHtmlArray("&lt;/tr>");
                                        }
                                        addToHtmlArray("&lt;/tbody>"), footerLine &amp;&amp; (addToHtmlArray("&lt;tfoot>&lt;tr>"), 
                                        addToHtmlArray(`&lt;td colspan="${bulletType.length}">${processInline(footerLine)}&lt;/td>`), 
                                        addToHtmlArray("&lt;/tr>&lt;/tfoot>")), addToHtmlArray("&lt;/table>");
                                    } else tableLines.forEach(line => {
                                        addToHtmlArray(`&lt;p>${processInline(line)}&lt;/p>`);
                                    }), footerLine &amp;&amp; lines.unshift(footerLine);
                                    break;
                                }

                              case /^&lt;([a-zA-Z]+)([^>]*)>/.test(meta.thisLine):
                                var openingTag = (listMatch = meta.thisLine.match(/^&lt;([a-zA-Z]+)([^>]*)>/)) ? listMatch[1] : null;
                                if (openingTag) {
                                    if (meta.thisLine.match(new RegExp(`^&lt;${openingTag}[^>]*>.*&lt;/${openingTag}>$`))) addToHtmlArray(meta.thisLine, !0); else {
                                        var rawHtmlStack = [ meta.thisLine ];
                                        let nextLine = lines.shift();
                                        for (;nextLine; ) {
                                            if (nextLine.match(new RegExp(`^&lt;/${openingTag}>`))) {
                                                rawHtmlStack.push(nextLine);
                                                break;
                                            }
                                            var nestedOpeningTagMatch = nextLine.match(/^&lt;([a-zA-Z]+)([^>]*)>/), nestedClosingTagMatch = nextLine.match(/^&lt;\/([a-zA-Z]+)>/);
                                            nestedOpeningTagMatch &amp;&amp; nestedOpeningTagMatch[1] || !nestedClosingTagMatch || !nestedClosingTagMatch[1] || rawHtmlStack[rawHtmlStack.length - 1] !== `&lt;${nestedClosingTagMatch[1]}>` ? rawHtmlStack.push(nextLine) : rawHtmlStack.pop(), 
                                            nextLine = lines.shift();
                                        }
                                        addToHtmlArray(rawHtmlStack.join("\n"), !0);
                                    }
                                    doContinue = !0;
                                }
                                break;

                              case meta.isEmpty:
                                doContinue = !0, closeAllTags();
                                break;

                              case /\s*#{1,6}\s+/.test(meta.thisLine):
                              case /^\s*(\*\s*){3,}$/.test(meta.thisLine) || /^\s*(-\s*){3,}$/.test(meta.thisLine) || /^\s*(?:_ ?){3,}$/.test(meta.thisLine):
                                addToHtmlArray("" + processInline(meta.thisLine)), 
                                doContinue = !0;
                                break;

                              default:
                                addToHtmlArray(`&lt;p>${processInline(meta.thisLine)}&lt;/p>`);
                            }
                            doContinue;
                        }
                    }(content), closeAllTags(), htmlArray.join("\n");
                };
            };
        },
        // ANCHOR Function Loader: convertJsonToHtml
        convertJsonToHtml: function() {
            return moduleSettings => {
                let logSyslogMessage = EASY_UTILS.getFunction({
                    functionName: "logSyslogMessage",
                    moduleSettings: moduleSettings
                });
                return ({
                    htmlJson
                }) => {
                    try {
                        var parsedJson = JSON.parse(htmlJson);
                        function processNode(node) {
                            if (!node.element) return "";
                            if ("text" === node.element) return node.children &amp;&amp; node.children[0]?.innerText ? node.children[0].innerText : "";
                            var combinedStyle = {
                                ...node.props?.style,
                                ...node.props?.inlineStyle
                            }, combinedStyle = Object.entries(combinedStyle).map(([ key, value ]) => key.replace(/([A-Z])/g, "-$1").toLowerCase() + `: ${value};`).join(" ");
                            let attributes = [];
                            combinedStyle &amp;&amp; attributes.push(`style="${combinedStyle}"`), 
                            node.props?.class?.length &amp;&amp; attributes.push(`class="${node.props.class.join(" ")}"`), 
                            node.props?.id &amp;&amp; attributes.push(`id="${node.props.id}"`), 
                            Object.keys(node.props || {}).filter(key => ![ "style", "inlineStyle", "class", "id" ].includes(key)).forEach(key => {
                                attributes.push(`${key}="${node.props[key]}"`);
                            });
                            combinedStyle = (node.children || []).map(processNode).join("");
                            return `&lt;${node.element} ${attributes.join(" ")}>${combinedStyle}&lt;/${node.element}>`;
                        }
                        let output = "";
                        return output = Array.isArray(parsedJson) ? parsedJson.map(processNode).join("") : processNode(parsedJson), 
                        moduleSettings.verbose &amp;&amp; logSyslogMessage({
                            severity: 7,
                            tag: "convertJsonToHtml",
                            transUnitId: "70000",
                            message: "Success"
                        }), output;
                    } catch (err) {
                        return logSyslogMessage({
                            severity: 3,
                            tag: "convertJsonToHtml",
                            transUnitId: "30000",
                            message: "" + err
                        }), "&lt;div>&lt;h1>Error transforming HTML JSON representation&lt;/h1>&lt;/div>";
                    }
                };
            };
        },
        // ANCHOR Function Loader: convertToSingleLine
        convertToSingleLine: function() {
            return moduleSettings => ({
                multiline
            }) => multiline.replace(/("[^"]*"|'[^']*')|\s+/g, (_, quoted) => quoted || " ");
        },
        // ANCHOR Function: createPhraseFactory
        createPhraseFactory: function() {
            return moduleSettings => {
                let replacePlaceholders = EASY_UTILS.getFunction({
                    functionName: "replacePlaceholders",
                    moduleSettings: moduleSettings
                });
                var getSharedForge = EASY_UTILS.getFunction({
                    functionName: "getSharedForge",
                    moduleSettings: moduleSettings
                }), moduleSettings = EASY_UTILS.getFunction({
                    functionName: "getSharedVault",
                    moduleSettings: moduleSettings
                }), getSharedForge = getSharedForge(), moduleSettings = moduleSettings();
                if (!getSharedForge.getFactory({
                    name: "PhraseFactory"
                })) {
                    let defaultLanguageCode = globalSettings.phraseLanguage || "enUS", loadedLanguagePhrases = {}, languageUsageCounts = {}, contributedLanguagePhrases = {}, playerLanguagesMap = moduleSettings.playerLanguages || {}, registeredLanguages = (moduleSettings.playerLanguages = playerLanguagesMap, 
                    new Set([ "enUS", "frFR" ]));
                    function loadOrCreateLanguage(languageCode) {
                        var builtInDictionary;
                        loadedLanguagePhrases[languageCode] || (builtInDictionary = (languageCode => "enUS" === languageCode ? {
                            0: "Success",
                            1: "Failure",
                            1e4: ".=> Initializing &lt;=.",
                            2e4: ".=> Ready &lt;=.",
                            20100: "Complete: {{ remark }} has been created.",
                            4e4: "Invalid Arguments: {{ remark }}",
                            40400: "Not Found: {{ remark }}",
                            5e4: "Error: {{ remark }}",
                            3e4: "Warning: {{ remark }}",
                            6e4: "Information: {{ remark }}",
                            7e4: "Debug: {{ remark }}",
                            "0x0D9A441E": "Tokens need to be selected or passed by --ids.",
                            "0x004A7742": "error",
                            "0x0B672E77": "warning",
                            "0x0004E2AF": "information",
                            "0x000058E0": "tip",
                            "0x02B2451A": "You entered the following command:",
                            "0x0834C8EE": "If you continue to experience issues contact the module author ({{ author }})."
                        } : "frFR" === languageCode ? {
                            0: "Succs",
                            1: "chec",
                            1e4: ".=> Initialisation &lt;=.",
                            2e4: ".=> Prt &lt;=.",
                            20100: "Termin : {{ remark }} a t cr.",
                            4e4: "Arguments invalides : {{ remark }}",
                            40400: "Non trouv : {{ remark }}",
                            5e4: "Erreur : {{ remark }}",
                            3e4: "Avertissement : {{ remark }}",
                            6e4: "Information : {{ remark }}",
                            7e4: "Dbogage : {{ remark }}",
                            "0x0D9A441E": "Des jetons doivent tre slectionns ou passs avec --ids.",
                            "0x004A7742": "erreur",
                            "0x0B672E77": "avertissement",
                            "0x0004E2AF": "information",
                            "0x000058E0": "conseil",
                            "0x02B2451A": "Vous avez entr la commande suivante :",
                            "0x0834C8EE": "Si le problme persiste, contactez l'auteur du module ({{ author }})."
                        } : null)(languageCode), loadedLanguagePhrases[languageCode] = builtInDictionary || {}, 
                        contributedLanguagePhrases[languageCode] &amp;&amp; Object.assign(loadedLanguagePhrases[languageCode], contributedLanguagePhrases[languageCode]), 
                        registeredLanguages.add(languageCode));
                    }
                    moduleSettings = {
                        get({
                            playerId = "default",
                            transUnitId,
                            expressions = {}
                        }) {
                            var playerId = playerLanguagesMap[playerId] || defaultLanguageCode, playerId = (loadedLanguagePhrases[playerId] || loadOrCreateLanguage(playerId), 
                            loadedLanguagePhrases[playerId]), fallbackDict = loadedLanguagePhrases[defaultLanguageCode] || {}, playerId = playerId[transUnitId] || fallbackDict[transUnitId];
                            return playerId ? replacePlaceholders({
                                string: playerId,
                                expressions: expressions
                            }) : transUnitId;
                        },
                        add({
                            newMap
                        }) {
                            for (var [ langCode, phraseMap ] of Object.entries(newMap)) registeredLanguages.add(langCode), 
                            contributedLanguagePhrases[langCode] = contributedLanguagePhrases[langCode] || {}, 
                            Object.assign(contributedLanguagePhrases[langCode], phraseMap), 
                            loadedLanguagePhrases[langCode] &amp;&amp; Object.assign(loadedLanguagePhrases[langCode], phraseMap);
                        },
                        setLanguage({
                            playerId,
                            language
                        }) {
                            var oldLang = playerLanguagesMap[playerId];
                            oldLang &amp;&amp; languageUsageCounts[oldLang] &amp;&amp; (languageUsageCounts[oldLang]--, 
                            languageUsageCounts[oldLang] &lt;= 0) &amp;&amp; (oldLang = oldLang, 
                            languageUsageCounts[oldLang] &lt;= 0) &amp;&amp; oldLang !== defaultLanguageCode &amp;&amp; delete loadedLanguagePhrases[oldLang], 
                            playerLanguagesMap[playerId] = language, loadedLanguagePhrases[language] || loadOrCreateLanguage(language), 
                            languageUsageCounts[language] = (languageUsageCounts[language] || 0) + 1;
                        },
                        getLanguages() {
                            var loadedLangs = Object.keys(loadedLanguagePhrases), loadedLangs = new Set([ ...registeredLanguages, ...loadedLangs ]);
                            return Array.from(loadedLangs);
                        },
                        remove({
                            language,
                            transUnitId
                        }) {
                            delete contributedLanguagePhrases[language]?.[transUnitId], 
                            loadedLanguagePhrases[language] &amp;&amp; delete loadedLanguagePhrases[language][transUnitId];
                        },
                        init() {
                            for (var langCode of Object.keys(loadedLanguagePhrases)) delete loadedLanguagePhrases[langCode];
                            for (let langCode of Object.keys(contributedLanguagePhrases)) delete contributedLanguagePhrases[langCode];
                            for (let langCode of Object.keys(languageUsageCounts)) delete languageUsageCounts[langCode];
                            for (var pid of Object.keys(playerLanguagesMap)) delete playerLanguagesMap[pid];
                            registeredLanguages.clear(), registeredLanguages.add(defaultLanguageCode), 
                            loadOrCreateLanguage(defaultLanguageCode), languageUsageCounts[defaultLanguageCode] = 0;
                        }
                    };
                    moduleSettings.setLanguage({
                        playerId: "default",
                        language: defaultLanguageCode
                    }), languageUsageCounts[defaultLanguageCode] = 0, getSharedForge.setFactory({
                        name: "PhraseFactory",
                        factory: moduleSettings
                    });
                }
                return getSharedForge.getFactory({
                    name: "PhraseFactory"
                });
            };
        },
        // ANCHOR Function: createTemplateFactory
        createTemplateFactory: function() {
            return moduleSettings => {
                let replacePlaceholders = EASY_UTILS.getFunction({
                    functionName: "replacePlaceholders",
                    moduleSettings: moduleSettings
                });
                var getSharedForge = EASY_UTILS.getFunction({
                    functionName: "getSharedForge",
                    moduleSettings: moduleSettings
                });
                let convertHtmlToJson = EASY_UTILS.getFunction({
                    functionName: "convertHtmlToJson",
                    moduleSettings: moduleSettings
                });
                moduleSettings = getSharedForge();
                if (!moduleSettings.getFactory({
                    name: "TemplateFactory"
                })) {
                    let templateMemoryMap = {
                        default: expressions => `
                &lt;table border="1" style="border-collapse: collapse; width: 100%;">
                    &lt;thead>
                        &lt;tr>
                            &lt;th style="padding: 8px; text-align: left; background-color: #34627B; color: white;">Key&lt;/th>
                            &lt;th style="padding: 8px; text-align: left; background-color: #34627B; color: white;">Value&lt;/th>
                        &lt;/tr>
                    &lt;/thead>
                    &lt;tbody>
                        ${Object.entries(expressions).map(([ key, value ], index) => `&lt;tr ${index % 2 == 0 ? 'style="background-color: #d9f7d1;"' : ""}>
                                &lt;td style="padding: 8px;">${key}&lt;/td>
                                &lt;td style="padding: 8px;">${value}&lt;/td>
                            &lt;/tr>`).join("")}
                    &lt;/tbody>
                    &lt;tfoot>
                        &lt;tr>
                            &lt;td style="padding: 8px; font-weight: bold; background-color: #34627B; color: white;" colspan="2">End of Data&lt;/td>
                        &lt;/tr>
                    &lt;/tfoot>
                &lt;/table>`
                    };
                    moduleSettings.setFactory({
                        name: "TemplateFactory",
                        factory: {
                            get: ({
                                template = "default",
                                expressions = {}
                            } = {}) => {
                                var loadedTemplate;
                                return templateMemoryMap[template] || ((loadedTemplate = "chatAlert" === template ? `
							&lt;div class="alert-box">
								&lt;h3>{{ title }}&lt;/h3>
								&lt;p>{{ description }}&lt;/p>
								&lt;div class="alert-code">
									&lt;p>{{ code }}&lt;/p>
								&lt;/div>
								&lt;p>{{ remark }}&lt;/p>
								&lt;p class="alert-footer">{{ footer }}&lt;/p>
							&lt;/div>` : null) ? templateMemoryMap[template] = loadedTemplate : template = "default"), 
                                "default" === template &amp;&amp; "function" == typeof templateMemoryMap.default ? templateMemoryMap.default(expressions) : (loadedTemplate = templateMemoryMap[template], 
                                replacePlaceholders({
                                    string: loadedTemplate,
                                    expressions: expressions
                                }));
                            },
                            set: ({
                                newMap
                            }) => {
                                Object.keys(templateMemoryMap).forEach(key => {
                                    delete templateMemoryMap[key];
                                }), Object.assign(templateMemoryMap, newMap);
                            },
                            add: ({
                                newTemplates
                            }) => {
                                Object.entries(newTemplates).forEach(([ name, htmlString ]) => {
                                    templateMemoryMap[name] = htmlString.trim();
                                });
                            },
                            remove: ({
                                template
                            }) => {
                                delete templateMemoryMap[template];
                            },
                            init: () => {
                                Object.keys(templateMemoryMap).forEach(key => {
                                    delete templateMemoryMap[key];
                                }), templateMemoryMap.default = convertHtmlToJson({
                                    html: htmlDefault
                                });
                            }
                        }
                    });
                }
                return moduleSettings.getFactory({
                    name: "TemplateFactory"
                });
            };
        },
        // ANCHOR Function: createThemeFactory
        createThemeFactory: function() {
            return moduleSettings => {
                let replacePlaceholders = EASY_UTILS.getFunction({
                    functionName: "replacePlaceholders",
                    moduleSettings: moduleSettings
                });
                moduleSettings = EASY_UTILS.getFunction({
                    functionName: "getSharedForge",
                    moduleSettings: moduleSettings
                })();
                if (!moduleSettings.getFactory({
                    name: "ThemeFactory"
                })) {
                    let themeMemoryMap = {
                        default: ""
                    };
                    moduleSettings.setFactory({
                        name: "ThemeFactory",
                        factory: {
                            get: ({
                                theme = "default",
                                expressions = {},
                                cssVars = {}
                            } = {}) => {
                                themeMemoryMap[theme] || ((loadedTheme = "chatAlert" === theme ? `
							/* Design Colors */
							:root {
								--ez-primary-background-color: #252B2C; 
								--ez-subdued-background-color: #f2f2f2; 
								--ez-text-color: #000000;
								--ez-overlay-text-color: #ffffff; 
								--ez-border-color: #000000; 
								--ez-shadow-color: #4d4d4d; 
							}
							
							.alert-box {
								border: 1px solid var(--ez-border-color);
								background-color: var(--ez-primary-background-color);
								padding: 10px;
								border-radius: 10px;
								color: var(--ez-text-color);
							}
							
							h3 {
								color: var(--ez-overlay-text-color);
								margin: 0;
								font-size: 1.2em;
								text-transform: uppercase;
							}
							
							p {
								margin: 5px 0;
							}
							
							.alert-code {
								margin: 8px 0;
								padding: 5px;
								background-color: var(--ez-subdued-background-color);
								border: var(--ez-shadow-color);
								border-radius: 5px;
								font-family: monospace;
							}
							
							.alert-footer {
								margin: 5px 0;
								font-size: 0.9em;
								color: var(--ez-shadow-color);
							}` : null) ? themeMemoryMap[theme] = loadedTheme : theme = "default");
                                var loadedTheme = themeMemoryMap[theme];
                                return replacePlaceholders({
                                    string: loadedTheme,
                                    expressions: expressions,
                                    cssVars: cssVars
                                });
                            },
                            set: ({
                                newMap
                            }) => {
                                Object.keys(themeMemoryMap).forEach(key => {
                                    delete themeMemoryMap[key];
                                }), Object.assign(themeMemoryMap, newMap);
                            },
                            add: ({
                                newThemes
                            }) => {
                                Object.entries(newThemes).forEach(([ name, themeString ]) => {
                                    themeMemoryMap[name] = themeString.trim();
                                });
                            },
                            remove: ({
                                theme
                            }) => {
                                delete themeMemoryMap[theme];
                            },
                            init: () => {
                                Object.keys(themeMemoryMap).forEach(key => {
                                    delete themeMemoryMap[key];
                                }), themeMemoryMap.default = '{"universal": {},"elements": {},"classes": {},"attributes": {},"functions": {},"ids": {}}';
                            }
                        }
                    });
                }
                return moduleSettings.getFactory({
                    name: "ThemeFactory"
                });
            };
        },
        // ANCHOR Function Loader: decodeCodeBlock
        decodeCodeBlock: function() {
            return moduleSettings => {
                let logSyslogMessage = EASY_UTILS.getFunction({
                    functionName: "logSyslogMessage",
                    moduleSettings: moduleSettings
                });
                return ({
                    text
                }) => "string" != typeof text ? (moduleSettings.verbose &amp;&amp; logSyslogMessage({
                    severity: 7,
                    tag: "decodeCodeBlock",
                    transUnitId: "70000",
                    message: "Invalid Argument: 'text' is not a string, returning input."
                }), text) : text.replace(/%%%LESSTHAN%%%/g, "&amp;lt;").replace(/%%%GREATERTHAN%%%/g, "&amp;gt;").replace(/%%%QUOTE%%%/g, "&amp;quot;").replace(/%%%APOSTROPHE%%%/g, "&amp;#39;").replace(/%%%SPACE%%%/g, " ").replace(/%%%NEWLINE%%%/g, "\n").replace(/%%%TAB%%%/g, "\t").replace(/%%%AMPERSAND%%%/g, "&amp;").replace(/%%%EQUAL%%%/g, "&amp;#61;").replace(/%%%ASTERISK%%%/g, "&amp;#42;").replace(/%%%UNDERSCORE%%%/g, "&amp;#95;").replace(/%%%TILDE%%%/g, "&amp;#126;").replace(/%%%BACKTICK%%%/g, "&amp;#96;").replace(/%%%DASH%%%/g, "&amp;#45;").replace(/%%%CARET%%%/g, "&amp;#94;").replace(/%%%DOLLAR%%%/g, "&amp;#36;").replace(/%%%LBRACKET%%%/g, "&amp;#91;").replace(/%%%RBRACKET%%%/g, "&amp;#93;").replace(/%%%LCURLY%%%/g, "&amp;#123;").replace(/%%%RCURLY%%%/g, "&amp;#125;").replace(/%%%LPAREN%%%/g, "&amp;#40;").replace(/%%%RPAREN%%%/g, "&amp;#41;");
            };
        },
        // ANCHOR Function Loader: encodeCodeBlock
        encodeCodeBlock: function() {
            return moduleSettings => {
                let logSyslogMessage = EASY_UTILS.getFunction({
                    functionName: "logSyslogMessage",
                    moduleSettings: moduleSettings
                });
                return ({
                    text
                }) => "string" != typeof text ? (moduleSettings.verbose &amp;&amp; logSyslogMessage({
                    severity: 7,
                    tag: "encodeCodeBlock",
                    transUnitId: "70000",
                    message: "Invalid Argument: 'text' is not a string, returning input."
                }), text) : text.replace(/&amp;/g, "%%%AMPERSAND%%%").replace(/&lt;/g, "%%%LESSTHAN%%%").replace(/>/g, "%%%GREATERTHAN%%%").replace(/"/g, "%%%QUOTE%%%").replace(/'/g, "%%%APOSTROPHE%%%").replace(/ /g, "%%%SPACE%%%").replace(/\n/g, "%%%NEWLINE%%%").replace(/\t/g, "%%%TAB%%%").replace(/=/g, "%%%EQUAL%%%").replace(/\*/g, "%%%ASTERISK%%%").replace(/_/g, "%%%UNDERSCORE%%%").replace(/~/g, "%%%TILDE%%%").replace(/`/g, "%%%BACKTICK%%%").replace(/-/g, "%%%DASH%%%").replace(/\^/g, "%%%CARET%%%").replace(/\$/g, "%%%DOLLAR%%%").replace(/\[/g, "%%%LBRACKET%%%").replace(/\]/g, "%%%RBRACKET%%%").replace(/\{/g, "%%%LCURLY%%%").replace(/\}/g, "%%%RCURLY%%%").replace(/\(/g, "%%%LPAREN%%%").replace(/\)/g, "%%%RPAREN%%%");
            };
        },
        // ANCHOR Function Loader: decodeNoteContent
        decodeNoteContent: function() {
            return moduleSettings => {
                let logSyslogMessage = EASY_UTILS.getFunction({
                    functionName: "logSyslogMessage",
                    moduleSettings: moduleSettings
                });
                return ({
                    text
                }) => "string" != typeof text ? (moduleSettings.verbose &amp;&amp; logSyslogMessage({
                    severity: 7,
                    tag: "decodeNoteContent",
                    transUnitId: "70000",
                    message: "Invalid Argument: 'text' is not a string, returning input."
                }), text) : text.replace(" ", "&amp;nbsp;").replace(/&lt;p>/g, "").replace(/&lt;\/p>/g, "").replace(/&lt;br>/g, "\n").replace(/&amp;lt;/g, "&lt;").replace(/&amp;gt;/g, ">").replace(/&amp;quot;/g, '"').replace(/&amp;#39;/g, "'").replace(/&amp;nbsp;/g, " ").replace(/&amp;amp;/g, "&amp;");
            };
        },
        // ANCHOR Function Loader: encodeNoteContent
        encodeNoteContent: function() {
            return moduleSettings => {
                let logSyslogMessage = EASY_UTILS.getFunction({
                    functionName: "logSyslogMessage",
                    moduleSettings: moduleSettings
                });
                return ({
                    text
                }) => "string" != typeof text ? (moduleSettings.verbose &amp;&amp; logSyslogMessage({
                    severity: 7,
                    tag: "encodeNoteContent",
                    transUnitId: "70000",
                    message: "Invalid Argument: 'text' is not a string, returning input."
                }), text) : text.replace(" ", "&amp;nbsp;").replace(/&amp;amp;/g, "&amp;").replace(/&amp;nbsp;/g, " ").replace(/&amp;#39;/g, "'").replace(/&amp;quot;/g, '"').replace(/&amp;gt;/g, ">").replace(/&amp;lt;/g, "&lt;").replace(/&lt;br>/g, "\n").replace(/&lt;\/p>/g, "").replace(/&lt;p>/g, "");
            };
        },
        // ANCHOR Function Loader: getGLobalSettings
        getGlobalSettings: function() {
            return moduleSettings => () => globalSettings;
        },
        // ANCHOR Function Loader: getSharedForge
        getSharedForge: function() {
            return moduleSettings => () => EASY_MODULE_FORGE;
        },
        // ANCHOR Function Loader: getSharedVault
        getSharedVault: function() {
            return moduleSettings => {
                let logSyslogMessage = EASY_UTILS.getFunction({
                    functionName: "logSyslogMessage",
                    moduleSettings: moduleSettings
                });
                return () => {
                    var vaultName = globalSettings.sharedVaultName;
                    return state[vaultName] || (state[vaultName] = {}, moduleSettings.verbose &amp;&amp; logSyslogMessage({
                        severity: 7,
                        tag: "getSharedVault",
                        transUnitId: "70000",
                        message: `Not Found: Shared vault undefined, initializing 'state.${vaultName}'.`
                    })), state[vaultName];
                };
            };
        },
        // ANCHOR Function Loader: logSyslogMessage
        logSyslogMessage: function() {
            return moduleSettings => ({
                severity,
                tag,
                transUnitId,
                message
            }) => {
                var severityMap = {
                    3: "ERROR",
                    4: "WARN",
                    6: "INFO",
                    7: "DEBUG"
                }, moduleName = moduleSettings?.readableName || "UNKNOWN_MODULE", severityMap = `&lt;${severityMap[severityMap[severity] ? severity : 6]}> ${new Date().toISOString()} [${moduleName}](${tag}): {"transUnitId": ${transUnitId}, "message": "${message}"}`;
                try {
                    return log(severityMap), severityMap;
                } catch (err) {}
            };
        },
        // ANCHOR Function Loader: parseChatCommands
        /**
		 * @summary Parse chat input into main and subcommands.
		 * @example
		 * const commandMap = parseChatCommands()(moduleSettings)({ apiCallContent: "!mycmd --alert --lang frFR" });
		 * log([...commandMap]); // [["--alert", []], ["--lang", ["frFR"]]]
		 */
        parseChatCommands: function() {
            return moduleSettings => ({
                apiCallContent
            }) => {
                let commandMap = new Map();
                return apiCallContent.trim().split("--").filter(segment => "" !== segment.trim()).forEach((segment, index) => {
                    0 === index &amp;&amp; segment.trim().startsWith("!") || ([ index, ...segment ] = segment.trim().split(/\s+/), 
                    index = index.toLowerCase().trim(), commandMap.set("--" + index, segment));
                }), commandMap;
            };
        },
        // ANCHOR Function Loader: parseChatSubcommands
        parseChatSubcommands: function() {
            return moduleSettings => ({
                subcommands
            }) => {
                let subcommandMap = {};
                return subcommands.forEach(arg => {
                    var value, delimiterMatch = arg.includes("|") ? "|" : arg.includes("#") ? "#" : null;
                    delimiterMatch ? ([ delimiterMatch, value ] = arg.split(delimiterMatch), 
                    subcommandMap[delimiterMatch] = value) : subcommandMap[arg] = !0;
                }), subcommandMap;
            };
        },
        // ANCHOR Function Loader: replacePlaceholders
        /**
		 * @summary Replace placeholders in a string with token values and evaluate inline expressions.
		 * @example
		 * const replaced = replacePlaceholders()(moduleSettings)({ string: "Hello {{name}}!", expressions: { name: "World" } });
		 * log(replaced); // "Hello World!"
		 */
        replacePlaceholders: function() {
            return moduleSettings => ({
                string,
                expressions = {},
                cssVars = {}
            }) => string.replace(/{{(.*?)}}/g, (_, key) => expressions[key.trim()] || "").replace(/\[\[(.*?)\]\]/g, (_, anExpression) => `&lt;span class="inline-rolls">[[${anExpression.trim()}]]&lt;/span>`).replace(/var\((--[\w-]+)\)/g, (_, cssVar) => cssVars[cssVar.trim()] || `var(${cssVar.trim()})`);
        },
        // ANCHOR Function Loader: renderTemplateAsync
        renderTemplateAsync: function() {
            return moduleSettings => {
                let templateFactory = EASY_UTILS.getFunction({
                    functionName: "createTemplateFactory",
                    moduleSettings: moduleSettings
                }), themeFactory = EASY_UTILS.getFunction({
                    functionName: "createThemeFactory",
                    moduleSettings: moduleSettings
                }), applyCssToHtmlJson = EASY_UTILS.getFunction({
                    functionName: "applyCssToHtmlJson",
                    moduleSettings: moduleSettings
                }), convertJsonToHtml = EASY_UTILS.getFunction({
                    functionName: "convertJsonToHtml",
                    moduleSettings: moduleSettings
                }), convertHtmlToJson = EASY_UTILS.getFunction({
                    functionName: "convertHtmlToJson",
                    moduleSettings: moduleSettings
                }), convertCssToJson = EASY_UTILS.getFunction({
                    functionName: "convertCssToJson",
                    moduleSettings: moduleSettings
                }), decodeCodeBlock = EASY_UTILS.getFunction({
                    functionName: "decodeCodeBlock",
                    moduleSettings: moduleSettings
                });
                return async ({
                    template,
                    expressions = {},
                    theme,
                    cssVars = {}
                }) => {
                    try {
                        var [ fetchedTemplate, fetchedTheme ] = await Promise.all([ templateFactory.get({
                            template: template,
                            expressions: expressions,
                            cssVars: cssVars
                        }), themeFactory.get({
                            theme: theme,
                            expressions: expressions,
                            cssVars: cssVars
                        }) ]), styledJson = applyCssToHtmlJson({
                            cssJson: convertCssToJson({
                                css: fetchedTheme
                            }),
                            htmlJson: convertHtmlToJson({
                                html: fetchedTemplate
                            })
                        });
                        return convertJsonToHtml({
                            htmlJson: decodeCodeBlock({
                                text: styledJson
                            })
                        });
                    } catch (err) {
                        throw new Error("" + err);
                    }
                };
            };
        },
        // ANCHOR Function Loader: whisperAlertMessageAsync
        whisperAlertMessageAsync: function() {
            return moduleSettings => {
                let renderTemplateAsync = EASY_UTILS.getFunction({
                    functionName: "renderTemplateAsync",
                    moduleSettings: moduleSettings
                }), whisperPlayerMessage = EASY_UTILS.getFunction({
                    functionName: "whisperPlayerMessage",
                    moduleSettings: moduleSettings
                }), PhraseFactory = EASY_UTILS.getFunction({
                    functionName: "createPhraseFactory",
                    moduleSettings: moduleSettings
                });
                return async ({
                    from,
                    to,
                    toId,
                    severity = 6,
                    apiCallContent,
                    remark
                }) => {
                    var severityEnum = {
                        error: {
                            code: 3,
                            titleTransUnitId: "0x004A7742",
                            bgColor: "#ffdddd",
                            titleColor: "#FF0000"
                        },
                        warning: {
                            code: 4,
                            titleTransUnitId: "0x0B672E77",
                            bgColor: "#FBE7A1",
                            titleColor: "#CA762B"
                        },
                        information: {
                            code: 6,
                            titleTransUnitId: "0x0004E2AF",
                            bgColor: "#b8defd",
                            titleColor: "#2516f5"
                        },
                        tip: {
                            code: 7,
                            titleTransUnitId: "0x000058E0",
                            bgColor: "#C3FDB8",
                            titleColor: "#16F529"
                        }
                    }, severityCodeMap = Object.fromEntries(Object.entries(severityEnum).map(([ key, value ]) => [ value.code, key ])), severityCodeMap = severityEnum["string" == typeof severity ? severity.toLowerCase() : severityCodeMap[severity] || "info"] || severityEnum.info, severity = {
                        title: PhraseFactory.get({
                            playerId: toId,
                            transUnitId: severityCodeMap.titleTransUnitId
                        }),
                        description: PhraseFactory.get({
                            playerId: toId,
                            transUnitId: "0x02B2451A"
                        }),
                        code: apiCallContent,
                        remark: remark,
                        footer: PhraseFactory.get({
                            playerId: toId,
                            transUnitId: "0x0834C8EE",
                            expressions: {
                                author: "" + moduleSettings.author
                            }
                        })
                    }, severityEnum = {
                        "--ez-primary-background-color": severityCodeMap.bgColor,
                        "--ez-overlay-text-color": severityCodeMap.titleColor
                    };
                    try {
                        var styledMessage = await renderTemplateAsync({
                            template: "chatAlert",
                            expressions: severity,
                            theme: "chatAlert",
                            cssVars: severityEnum
                        });
                        return whisperPlayerMessage({
                            from: from,
                            to: to,
                            message: styledMessage
                        }), 0;
                    } catch (err) {
                        throw new Error("" + err);
                    }
                };
            };
        },
        // ANCHOR Function Loader: whisperPlayerMessage
        /**
		 * @summary Whisper a message to a player in chat.
		 * @example
		 * whisperPlayerMessage()(moduleSettings)({ from: "System", to: "gm", message: "Hello GM!" });
		 */
        whisperPlayerMessage: function() {
            return moduleSettings => {
                let logSyslogMessage = EASY_UTILS.getFunction({
                    functionName: "logSyslogMessage",
                    moduleSettings: moduleSettings
                });
                return ({
                    from,
                    to,
                    message
                }) => {
                    from = from || moduleSettings.readableName, to = to || "gm";
                    try {
                        return sendChat(from, `/w ${to} ` + message), from + `;;${to};;` + message;
                    } catch (err) {
                        return logSyslogMessage({
                            severity: 3,
                            tag: "whisperPlayerMessage",
                            transUnitId: "30000",
                            message: "" + err
                        }), `!${from};;${to};;` + message;
                    }
                };
            };
        }
    }, loadedFunctions = (on("ready", () => {
        var requiredFunctions;
        if (0 == (void 0 !== EASY_UTILS ? (requiredFunctions = [ "getSharedForge", "createPhraseFactory", "createTemplateFactory", "createThemeFactory", "whisperAlertMessageAsync", "logSyslogMessage", "parseChatCommands" ], 
        Utils = EASY_UTILS.fetchUtilities({
            requiredFunctions: requiredFunctions,
            moduleSettings: moduleSettings
        }), PhraseFactory = Utils.createPhraseFactory, TemplateFactory = Utils.createTemplateFactory, 
        ThemeFactory = Utils.createThemeFactory, Utils.logSyslogMessage({
            severity: 6,
            tag: "checkInstall",
            transUnitId: "10000",
            message: PhraseFactory.get({
                transUnitId: "10000"
            })
        }), 0) : (requiredFunctions = `&lt;ERROR> ${new Date().toISOString()} [${moduleSettings.readableName}](checkInstall): {"transUnitId": 50000, "message": "Unexpected Error occurred initializing ${moduleSettings.globalName}"}`, 
        log(requiredFunctions), 1))) Utils.logSyslogMessage({
            severity: 6,
            tag: "registerEventHandlers",
            transUnitId: "20000",
            message: PhraseFactory.get({
                transUnitId: "20000"
            })
        });
    }), {});
    // ANCHOR Property: moduleSettings
    return {
        // ANCHOR Method: getFunction
        getFunction: ({
            functionName,
            moduleSettings
        }) => {
            if (functionLoaders[functionName]) return loadedFunctions[functionName] || (loadedFunctions[functionName] = functionLoaders[functionName]()), 
            factoryFunctions.includes(functionName) || "function" == typeof loadedFunctions[functionName] ? loadedFunctions[functionName](moduleSettings) : loadedFunctions[functionName];
            Utils.logSyslogMessage({
                severity: 4,
                tag: moduleSettings.readableName + ":checkInstall",
                transUnitId: "40400",
                message: PhraseFactory.get({
                    transUnitId: "40400",
                    expressions: {
                        remark: functionName
                    }
                })
            });
        },
        // ANCHOR Method: fetchedUtilities
        fetchUtilities: ({
            requiredFunctions,
            moduleSettings
        }) => requiredFunctions.reduce((accumulator, functionName) => (accumulator[functionName] = EASY_UTILS.getFunction({
            functionName: functionName,
            moduleSettings: moduleSettings
        }), accumulator), {})
    };
})();
// ANCHOR Object: EASY_UTILS</code></pre>
        </article>
    </section>




            </div>
            
            <footer class="footer">
                <div class="content has-text-centered">
                    <p>Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.11</a></p>
                    <p class="sidebar-created-by">
                        <a href="https://github.com/SoftwareBrothers/better-docs" target="_blank">BetterDocs theme</a> provided with <i class="fas fa-heart"></i> by
                        <a href="http://softwarebrothers.co" target="_blank">SoftwareBrothers - JavaScript Development Agency</a>
                    </p>
                </div>
            </footer>
            
        </div>
        <div id="side-nav" class="side-nav">
        </div>
    </div>
<script src="scripts/app.min.js"></script>
<script>PR.prettyPrint();</script>
<script src="scripts/linenumber.js"> </script>


</body>
</html>
